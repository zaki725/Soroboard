---
alwaysApply: true
---

---

description: "backend/配下の実装をする前に必ず読むべき内容"
globs: backend/\*\*
alwaysApply: false

---

まず、このファイルを理解したら「backend-rule を読みました。」と言ってください。
このルールは backend/ の開発作業に適用してください。

# 概要

このプロジェクトのバックエンドは、**Nest.js** フレームワークを使用し、**DDD（ドメイン駆動開発）** と **CQRS（Command Query Responsibility Segregation）** を組み合わせたアーキテクチャを採用しています。

## CQRS アーキテクチャ

このプロジェクトでは、**Event Sourcing** ではなく **State Sourcing** に CQRS を組み込んでいます。これにより、**Command（書き込み）** 側と **Query（読み取り）** 側で同じデータベースを参照します。

この構成を採用する主な理由は、Command 側で DDD を用いると、データ取得処理（`Get`）が複雑になりがちだからです。そのため、以下のように役割を分けています。

- **Command 側**: DDD を用いて、データの書き込み・更新・削除ロジックを扱います。
- **Query 側**: **Port-Adapter パターン** に基づき、Prisma を直接使用して読み取り処理を最適化します。

Command と Query はデータベースを共有しますが、それ以外の機能（ユーティリティ関数など）は共有しません。

## ディレクトリ構成

`src` ディレクトリ配下は、役割に応じて分割されています。

```
├── src
│   ├── command   # 書き込み・更新・削除処理
│   │   ├── application  # アプリケーションサービス層
│   │   ├── controller   # コントローラー層
│   │   ├── domain       # ドメイン層（リポジトリインターフェースなど）
│   │   ├── dto          # DTO（データ転送オブジェクト）定義
│   │   ├── infra        # インフラストラクチャ層（リポジトリ実装など）
│   │   ├── constants    # 定数定義（イベントタイプ、インジェクショントークンなど）
│   │   └── types        # 型定義
│   ├── query     # 読み取り専用API処理
│   │   ├── application  # アプリケーションサービス層
│   │   ├── controller   # コントローラー層
│   │   ├── dao          # DAO（データアクセスオブジェクト）層
│   │   ├── dto          # DTO定義
│   │   └── types        # 型定義
│   ├── modules   # モジュール定義（Nest.jsモジュール）
│   │             # - すべてのモジュールは必ずこのフォルダに配置する
│   │             # - controller配下にはモジュールを配置しない
│   │             # - Query/Commandごとにモジュールを分離
│   │             # - 統合モジュールでQuery/Commandをまとめる
│   │             # - 例: modules/company/company-query.module.ts, modules/company/company-command.module.ts, modules/company/company.module.ts
│   ├── common    # 共通処理
│   │   ├── errors       # エラー定義
│   │   ├── filters      # フィルター（グローバル例外フィルターなど）
│   │   ├── middleware   # ミドルウェア
│   │   └── pipes        # パイプ（バリデーションパイプなど）
│   └── config    # 設定（ロガーなど）
```

## 依存関係

各層の依存関係は以下の通りです。

- **Command**: `controller` -\> `application` -\> `domain` \<- `infra`
- **Query**: `controller` -\> `application` \<- `dao`

## モジュール構成

### モジュール配置の原則

- **すべてのモジュールは必ず `modules/` フォルダに配置する**
- **`controller/` 配下や `application/` 配下にはモジュールを配置してはいけない**
- モジュールは機能ごとに `modules/{feature-name}/` 配下にまとめる

### Query/Command 分離

- **Query 側と Command 側でモジュールを分離する**
- `modules/{feature-name}/`配下に以下のファイルを作成する
  - `{feature-name}-query.module.ts`: Query 側のモジュール
  - `{feature-name}-command.module.ts`: Command 側のモジュール
  - `{feature-name}.module.ts`: 統合モジュール（Query/Command をまとめる）

### モジュールの配置例

```
modules/
  └── company/
      ├── company-query.module.ts      # Query側のモジュール（controller、service、daoを定義）
      ├── company-command.module.ts    # Command側のモジュール（controller、service、repositoryを定義）
      └── company.module.ts            # 統合モジュール（Query/Commandをまとめる）
```

```ts
// modules/company/company-query.module.ts
// Query側のモジュール（query/controller、query/application、query/daoを定義）
@Module({
  controllers: [CompanyController], // query/controller/company/company.controller.ts
  providers: [
    CompanyService, // query/application/company/company.service.ts
    CompanyDao, // query/dao/company/company.dao.ts
    // PrismaServiceはPrismaModuleから提供されるため、providersには書かない
  ],
  exports: [CompanyDao], // Command側で使用するためにexport
})
export class CompanyQueryModule {}

// modules/company/company-command.module.ts
// Command側のモジュール（command/controller、command/application、command/infraを定義）
@Module({
  imports: [CompanyQueryModule], // Query側のDAOを使用するためにimport
  controllers: [CompanyController], // command/controller/company/company.controller.ts
  providers: [
    CompanyService, // command/application/company/company.service.ts
    {
      provide: INJECTION_TOKENS.ICompanyRepository,
      useClass: CompanyRepository, // command/infra/company/company.repository.ts
    },
    CompanyRepository,
    // CompanyDao は CompanyQueryModule から解決されるため providers には書かない
    // PrismaServiceはPrismaModuleから提供されるため、providersには書かない
  ],
})
export class CompanyCommandModule {}

// modules/company/company.module.ts
// 統合モジュール（Query/Commandをまとめる）
@Module({
  imports: [CompanyQueryModule, CompanyCommandModule],
})
export class CompanyModule {}
```

### AppModule での使用

- **AppModule では統合モジュールのみをインポートする**
- Query/Command の個別モジュールは直接インポートしない
- **`PrismaModule`はグローバルモジュールとして`AppModule`でインポートする**

```ts
// app.module.ts
@Module({
  imports: [
    PrismaModule, // グローバルモジュールとしてインポート（全モジュールでPrismaServiceが利用可能になる）
    RecruitYearModule, // 統合モジュールのみ
    // ...
  ],
  providers: [], // PrismaServiceはPrismaModuleに任せるので空でOK
})
export class AppModule {}
```

### PrismaService の扱い

- **`PrismaService`は必ず`PrismaModule`経由で使用する**
- **各モジュールの`providers`に`PrismaService`を直接書いてはいけない**
- **`PrismaModule`はグローバルモジュールとして`AppModule`でインポートする**

#### 理由

複数のモジュールで`PrismaService`を`providers`に直接書くと、NestJS はそれぞれで別々のインスタンス（DB 接続）を作成してしまいます。これにより：

- DB 接続数が増えすぎる
- シングルトンが保てなくなる
- メモリの無駄

#### 実装方法

1. **`PrismaModule`を使用**

   - `src/prisma/prisma.module.ts`で定義されているグローバルモジュールを使用
   - `@Global()`デコレータにより、一度インポートすれば全モジュールで利用可能

2. **各モジュールでの使用**
   - `providers`に`PrismaService`を書かない
   - コンストラクタで直接注入して使用
   ```typescript
   @Injectable()
   export class SomeRepository {
     constructor(private readonly prisma: PrismaService) {}
     // PrismaServiceを使用
   }
   ```

# Strict Rule

以下の項目は、プロジェクトの整合性を保つ上で特に重要なルールです。これらに違反している箇所を見つけたら、些細なことでも報告してください。

## 開発全般

- データ加工（集計、フィルタリング、結合など）のロジックは、アプリケーションロジックではなく、可能な限りデータベースクエリで完結させること

  - 例
    - 条件でフィルタリングする場合、アプリケーションで全件取得せず、WHERE 句を使いデータベースでフィルタリングする
    - 合計値を計算する場合、アプリケーションで全件取得せず、SUM()関数を使いデータベースで合計する

- **日付操作は必ず DateUtil を使用すること**

  - `new Date()`や`Date.now()`を直接使用してはいけない
  - すべての日付操作は`common/utils/date.utils.ts`のユーティリティ関数を使用する
  - 現在日時を取得する場合は`getCurrentDate()`を使用する
  - 日付のフォーマットは`formatDateToJST()`や`formatDateToISOString()`を使用する

- **エラーメッセージとバリデーションメッセージは定数から取得すること**

  - すべてのエラーメッセージとバリデーションメッセージは`common/constants/`配下の定数ファイルから取得する
  - `common/constants/index.ts`から必要な定数をインポートする
  - バリデーションメッセージは`validation.ts`の`REQUIRED`、`INVALID`、`MIN_LENGTH`を使用する
  - 業務エラーメッセージは`business-error.ts`の`CREATE`、`UPDATE`、`ID_REQUIRED`、`getEntityIdRequired`を使用する
  - リソース未検出エラーメッセージは`not-found-error.ts`の`getResourceNotFound`を使用する
  - システムエラーメッセージは`system-error.ts`の`INTERNAL_SERVER_ERROR`、`VALIDATION_ERROR`を使用する
  - 文字列リテラルで直接エラーメッセージやバリデーションメッセージを定義してはいけない

- テスト容易性の確保

  - DAO 層やリポジトリ層では外部依存（現在時刻、乱数など）を直接使用せず、パラメータとして注入可能にすること
  - インターフェース設計時にテスト容易性を考慮し、必要に応じて依存性注入を可能にすること

- 型チェックの実行

  - タスク実行時に既存のコードと整合性が取れているか確認するために、適宜`npm run test`, `npm run tsc`を実行すること
  - タスク完了時に`npm run fix-all`を実行し、整形すること

- エラーハンドリング
  - エラーはカスタムエラーを作成し`throw new Error()`を使ってはいけない
  - **各層でバリデーションを行わない**
    - バリデーションは各層の責務ではなく、リポジトリ層や DAO 層ではバリデーションを行わない
    - バリデーションが必要な場合は、アプリケーション層の DTO の中で zod を用いて行う
  - エラーを投げる場合は、必ずカスタムアプリケーションエラー（`ApplicationError`を継承したエラー）を使用する
    - リポジトリ層や DAO 層でエラーを投げる場合は、カスタムエラーを使用する
    - 例外的な状況（予期しないエラーなど）以外で`throw new Error()`を使用してはいけない
  - エラーメッセージは必ず定数ファイル（`common/constants/`配下）から取得すること
  - エラーはそれぞれの層で以下のように包み直す

```ts: application-layer-function

function someServiceFunction(){
  try{
    someRepositoryMethod()
  }catch(error){
    if (error instanceof NotFoundRepositoryError){
      throw new NotFoundApplicationError(error) // エラーをその層のカスタムエラー型に詰めなおす
    }
    throw error
  }
}

```

## Command

- ドメイン層とアプリケーション層以外はユビキタス言語で記載しない。
  - コントローラー層、リポジトリ層は`create`や`update`等の RESTAPI の言葉で記載すること
- `upsert`ではなく`create`と`update`を使うこと
  - `upsert`は楽観的ロックが使えないため使用しない
  - Query 側の DAO を使って存在確認を行い、存在する場合は`update`、存在しない場合は`create`を実行する
  - try-catch はなるべく使わない
- **infra 層はインターフェースにする**
  - リポジトリは`domain/`配下にインターフェースを定義し、`infra/`で実装する
  - アプリケーション層はインターフェースに依存する
- **リポジトリの引数は Entity にする**
  - リポジトリインターフェースのメソッド引数は、個別のプロパティではなく Entity オブジェクトを受け取る
  - Entity は`domain/{feature-name}/`配下に定義する
  - 例: `create(company: CompanyEntity): Promise<CompanyEntity>`
- **リポジトリの戻り値はドメインエンティティにする**
  - リポジトリのメソッドは Prisma の型（例: `SearchCondition`）ではなく、ドメインエンティティ（例: `SearchConditionEntity`）を返す
  - Prisma から取得したデータは、Mapper クラスの`toDomain`メソッドを使用してドメインエンティティに変換する
  - 例:
    ```ts
    async create(entity: SearchConditionEntity): Promise<SearchConditionEntity> {
      const data = await this.prisma.searchCondition.create({
        data: SearchConditionMapper.toPersistence(entity),
      });
      return SearchConditionMapper.toDomain(data);
    }
    ```
- **Mapper クラスの実装**
  - Mapper クラスは`domain/{feature-name}/`配下に定義する
  - Mapper クラスには以下のメソッドを実装する
    - `toDomain(data: PrismaType): Entity`: Prisma の型からドメインエンティティに変換
    - `toPersistence(entity: Entity): {...}`: ドメインエンティティから Prisma の保存用データ形式に変換（`id`、`createdAt`、`updatedAt`は含めない）
    - `toUpdatePersistence(entity: Entity): {...}`: ドメインエンティティから Prisma の更新用データ形式に変換（`id`、`createdAt`は含めない、`updatedAt`は Prisma の`@updatedAt`で自動管理されるため含めない）
  - `toPersistence`と`toUpdatePersistence`の戻り値の型は、`Omit`や`Partial`を使わず、明示的な型定義を使用する
  - 例:
    ```ts
    static toPersistence(entity: SearchConditionEntity): {
      formType: string;
      name: string;
      urlParams: string;
      recruitYearId: number | null;
      createdBy: string;
      updatedBy: string;
    } {
      return {
        formType: entity.formType,
        name: entity.name,
        urlParams: entity.urlParams,
        recruitYearId: entity.recruitYearId,
        createdBy: entity.createdBy,
        updatedBy: entity.updatedBy,
      };
    }
    ```
- **command 側に`findOne`などの読み取りメソッドを定義しない**
  - 読み取り処理は Query 側の DAO に定義する
  - command 側の service で Query 側の DAO を注入して使用する
- **イベントタイプは定数で管理する**
  - `command/constants/event-types.ts`に定数として定義する
  - 文字列リテラルを直接使用しない
- 外部サービスと連携しているテーブル（例: `AtsysApplicant` テーブル, `ApplicantSelectionProcess` テーブル）は、\*\*`command` 配下で直接更新してはいけない
  - 外部サービスから連携されているか否かは Prisma のコメントアウトを確認
- 外部連携はコントローラー層、サービス層、リポジトリ層で別ファイルで定義すること
  - ドメイン層で定義しているインターフェースも別で定義する
  - 例：カレンダー登録(GoogleCalendar)に関する処理を含むファイルは分割する
    - backend/src/command/controller/interview-slot/http/interview-slot.controller.ts
    - backend/src/command/controller/interview-slot/http/interview-slot-calendar.controller.ts
- **Outbox パターンの実装**
  - 外部システムと連携するテーブルを更新する際は、outbox テーブルにイベントを記録する
  - リポジトリ層でトランザクション内で outbox エントリを作成する
- **Entity の作成はファクトリメソッドを使用する**

  - サービス層で Entity を`new`で直接作成してはいけない
  - Entity クラスには`static create`メソッドを実装し、コンストラクターは`private`にする
  - Entity の作成は必ずファクトリメソッド（`static create`）を使用する
  - 例:

    ```ts
    export class SearchConditionEntity {
      private constructor(props: SearchConditionProps) {
        // ...
      }

      static create(props: SearchConditionProps): SearchConditionEntity {
        return new SearchConditionEntity(props);
      }
    }
    ```

- ビジネスロジックの実装可能箇所は Domain ロジックに記載
- ドメインサービスは以下の制約にしたがって実装する
  - 複数 entity に渡る処理
  - infra 層（外部依存）を利用してはいけない
    - infra 層を利用する場合は、アプリケーションサービスに記載する
    - **どこにも依存していないか？**を基準に考える

## Query

- 原則「読み取り専用」。DAO 層での書き込み操作（create/update/delete/upsert/raw-insert 等）は禁止
- 複雑な集計・フィルタは DB 側（Prisma/SQL）で完結させる（アプリ側で全件ロードしない）
- **DTO 変換は DTO クラス内に変換メソッドを作成する**

  - DTO への変換処理は、DTO クラス内に静的メソッド（`static`）として定義する
  - Command 側のエンティティから DTO を作成する場合は`fromEntity`メソッドを使用
  - Query 側の DAO から取得した Prisma データから DTO を作成する場合は`fromQuery`メソッドを使用
  - 例:

    ```ts
    export class SearchConditionResponseDto {
      // ...

      /**
       * Command側のエンティティからDTOを作成
       */
      static fromEntity(
        searchCondition: SearchConditionEntity
      ): SearchConditionResponseDto {
        // ...
      }

      /**
       * Query側のDAOから取得したデータからDTOを作成
       */
      static fromQuery(
        searchCondition: SearchCondition
      ): SearchConditionResponseDto {
        // ...
      }
    }
    ```

- **`recruit_year_id`を持つテーブルの検索条件には、必ずフロントから渡される`recruitYearId`を含める**
  - クエリパラメータから`recruitYearId`を取得し、DAO 層でフィルタリング条件に含める
  - 例: `findAll({ recruitYearId })`で`recruitYearId`を必須パラメータとして受け取る
  - **`recruitYearId`は NULL 許容しない**（必須パラメータ）
  - **DTO でバリデーションを必ずかける**
    - `ZodValidationPipe`を使用して、コントローラー層で DTO をバリデーションする
    - `recruitYearId`は必須で、正の整数であることをバリデーションする
    - 例: `z.string().min(1, '年度IDは必須です').transform((val) => Number(val)).refine((val) => !Number.isNaN(val) && val > 0, { message: '年度IDは正の整数である必要があります' })`

# コーディングスタイル

## 関数とクラス

- **メソッドは原則 1 つの責任を持つように分割する**

  - メソッドが長くなる場合は、意味のある単位で適切に分割する
  - 可読性と保守性を向上させる
  - ただし、Prisma のクエリビルド（include や where がネストする場合）、Zod のスキーマ定義、Mapper の変換ロジックなど、構造的に縦に長くなる場合は無理に分割せず、可読性を優先する

- 関数の引数は常に keyword arguments 形式で記載すること

  - 引数が 2 つ以上の場合は必ずオブジェクト形式で受け取る
  - 例: `function example({ param1, param2 }: { param1: string; param2: number })`

- **DTO の命名は Request/Response を明示的に定義する**

  - リクエスト用: `{機能}RequestDto` または `{機能}RequestSchema`
  - レスポンス用: `{機能}ResponseDto`
  - 例: `UpdateRecruitYearRequestDto`, `RecruitYearResponseDto`

- **バリデーションは DTO 内で自動実行する**

  - コントローラー層で手動バリデーションを行わない
  - `ZodValidationPipe`を使用して DTO 内で自動バリデーションを実行する

- バリデーション関数の 返り値は Boolean とする
  - 関数内で条件を満たさない場合は、`throw new Error`ではなく、false を返すこと

## 可読性と型安全

- any 型や型アサーション（`as`）、非ヌル宣言（`!`）は原則用いない

  - 用いる場合は必ずコメントアウトで理由を添えること
  - Prisma クライアントの型エラーは、マイグレーションを実行して`prisma generate`で解決すること
  - 型アサーションで回避するのではなく、スキーマを更新して Prisma クライアントを再生成すること

- **分岐や switch は極力使わず、マッピングやオブジェクトを使用する**

  - 条件分岐は可読性を下げ、バグの温床になりやすい
  - マッピングやオブジェクトを使うことで、データ駆動的なコードになり保守性が向上する

  ```ts
  # OK: マッピングを使用
  const statusColorMap: Record<string, string> = {
    success: "green",
    error: "red",
    warning: "yellow",
  };
  const color = statusColorMap[status] || "gray";

  const logLevelMap: Record<
    string,
    { method: 'error' | 'warn' | 'log'; trace?: string }
  > = {
    error: { method: 'error', trace: undefined },
    warn: { method: 'warn' },
    log: { method: 'log' },
  };
  const logConfig = logLevelMap[level] || logLevelMap.log;

  # NG: 分岐を使用
  let color: string;
  if (status === "success") {
    color = "green";
  } else if (status === "error") {
    color = "red";
  } else if (status === "warning") {
    color = "yellow";
  } else {
    color = "gray";
  }

  # NG: switchを使用
  switch (status) {
    case "success":
      color = "green";
      break;
    case "error":
      color = "red";
      break;
    case "warning":
      color = "yellow";
      break;
    default:
      color = "gray";
  }
  ```

- if 文はネストが深くならないように記述すること（原則 2 段まで）

  - 複雑なネストによる可読性低下・バグ混入を防ぐ
  - ただし、マッピングやオブジェクトで代替できない場合のみ使用する

- ハードコーディングはしないこと。
  - 検証環境や本番環境によって異なりそうなもの定数は.env で管理すること

## エラーとログ

- エラーメッセージはすべて日本語で表示すること
- ログ出力は`console.log`系ではなく`this.logger.log`のようなカスタムログ出力を用いること
  - `backend/src/config/custom-logger.service.ts`を DI して用いること
- **ログ戦略**

  - **すべてのログに`traceId`を自動付与**
    - CLS（Continuation Local Storage）を使用してリクエストごとのコンテキストを管理
    - `LoggingInterceptor`がリクエストごとに`traceId`を生成し、CLS に保存
    - `CustomLoggerService`が自動的に CLS から`traceId`を取得してログに含める
  - **構造化ログ（JSON 形式）で出力**
    - すべてのログは以下の JSON 形式で出力される
    ```json
    {
      "traceId": "01KAYWZQY4BDMP31RCX6GRWV7D",
      "timestamp": "2025-11-26T01:38:28.422Z",
      "level": "LOG",
      "context": "RepositoryName",
      "message": "ログメッセージ"
    }
    ```
  - **ログレベルの使い分け**
    - `log`: 通常の情報ログ（デフォルト）
    - `warn`: 警告（400 番台の HTTP エラー、バリデーションエラーなど）
    - `error`: エラー（500 番台の HTTP エラー、予期しないエラーなど）
    - `debug`: デバッグ情報（開発環境のみ）
    - `verbose`: 詳細情報（開発環境のみ）
  - **ログの出力方法**

    ```typescript
    @Injectable()
    export class SomeService {
      constructor(private readonly logger: CustomLoggerService) {}

      someMethod() {
        this.logger.log("処理が完了しました", "SomeService");
        this.logger.warn("警告メッセージ", "SomeService");
        this.logger.error(error, undefined, "SomeService");
      }
    }
    ```

  - **エラーハンドリングでのログ出力**
    - リポジトリ層やサービス層の`catch`ブロックでエラーログを必ず出力する
    - カスタムエラーに変換する前にログを出力
    ```typescript
    try {
      // 処理
    } catch (error) {
      this.logger.error(error, undefined, "RepositoryName");
      // カスタムエラーに変換
      throw new NotFoundError("リソース", id);
    }
    ```
  - **ログ出力のベストプラクティス**
    - エラーログは必ず出力する（`catch`ブロックで予期しないエラーが発生した場合は必ずログを出力）
    - コンテキスト名を適切に設定する（サービス層: `ServiceName`、リポジトリ層: `RepositoryName`、コントローラー層: `ControllerName`）
    - エラーログにはスタックトレースを含める（`this.logger.error(error, undefined, 'Context')`の形式で、Error オブジェクトを渡すと自動的にスタックトレースが含まれる）
    - 機密情報を含めない（パスワード、トークン、個人情報などはログに出力しない）

- エラーレスポンスは以下のような形式で記載し簡易的な記載は行わないこと

  ```ts
  // OK
  throw new HttpException(
    {
      statusCode: HttpStatus.BAD_REQUEST,
      message: "ログインパスワードは6-15文字で、空白を含んでいてはいけません",
      error: "Bad Request",
    },
    HttpStatus.BAD_REQUEST,
    {
      cause: error,
    }
  );

  // NG
  throw new BadRequestException(
    "ログインパスワードは6-15文字で、空白を含んでいてはいけません"
  );
  ```

# テスト

## 開発全般

- テストでは固定値を使用し、再現性と安定性を確保すること
- 動的な値（new Date()など）をテストで使用する場合は、テストの意図を明確にすること
- 必ず「正常系」,「異常系」をプレフィックスとして設けること
  - 例
    - `it('異常系: メモが1000文字を超過する場合', async () => {`
    - `it('正常系: 面接官作成成功', async () => {`
- 新規作成した関数や例外を投げる処理があれば必ずテストケースに含める
- 境界条件は必ずテストケースに含める

## Command

- controller 層と repository 層のテストでは、モックを利用せず、直接 DB を使用してテスト

## Query

- **Controller/Service 層**: モックテストで OK
- **DAO 層**: 実 DB（Docker などで立ち上げたテスト用 DB）を使った結合テストを推奨
  - DAO 層の主な責務は「複雑な SQL（Prisma クエリ）の構築」であるため、Prisma をモックしてしまうと「フィルタリング条件が正しいか」「結合（include/join）が正しいか」「生クエリの構文が合っているか」という、Query 側で最も担保したいロジックがテストできません
  - モックテストでは「Prisma を呼んだこと」しか確認できず、バグ（例：WHERE 句の条件ミス）を見逃す可能性が高いです
  - Prisma の挙動を含めてテストすることで、Query 側の品質を担保します

## テストコード（結合テスト・E2E テスト）

- **テスト前に必ずデータベースをクリーンアップすること**
  - `beforeEach`でテストで使用するテーブルのデータを削除する
  - 並列実行時の競合を防ぐため、`afterEach`だけでなく`beforeEach`でもクリーンアップを行う
  - 例: `await prisma.company.deleteMany(); await prisma.recruitYear.deleteMany();`
- **テスト後にデータベースをクリーンアップすること**
  - `afterEach`でテストで使用するテーブルのデータを削除する
  - テストが終了した後にアプリケーションをクローズする
  - 例: `await prisma.company.deleteMany(); await prisma.recruitYear.deleteMany(); await app.close();`
- **リポジトリ層のエラーハンドリングテスト**
  - Prisma のエラーコード`P2025`（レコードが見つからない）をキャッチし、適切なカスタムエラー（`NotFoundError`など）をスローする
  - リポジトリ層の`update`メソッドなどで、存在しない ID で更新しようとした場合は 404 エラーを返すようにする
  - 例: `if (error instanceof PrismaClientKnownRequestError && error.code === 'P2025') { throw new NotFoundError('会社', company.id); }`
- **編集したテストコードは必ずローカルで実行して確認すること**
  - `npm run test`を実行して、テストが正常に通過することを確認する
  - テストを修正した場合は、必ずローカルで実行して問題がないことを確認してからコミットする
